name: Slack Notifications

on:
  # Triggered when deploy-reports workflow completes
  workflow_run:
    workflows: ['Deploy Playwright HTML Report to GitHub Pages']
    types:
      - completed

  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      status:
        description: 'Test notification status'
        required: true
        default: 'success'
        type: choice
        options:
          - success
          - failure

permissions:
  actions: read # Required to query workflow runs via GitHub API
  contents: read # Required to checkout repository

jobs:
  notify-slack:
    runs-on: ubuntu-latest
    if: false # Workflow disabled - remove 'false &&' to enable
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Install jq for JSON parsing
        run: |
          sudo apt-get update && sudo apt-get install -y jq

      - name: Get test and deployment status
        id: status
        run: |
          # Default values for manual trigger
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "deployment_status=${{ github.event.inputs.status }}" >> $GITHUB_OUTPUT
            echo "trigger=manual" >> $GITHUB_OUTPUT
            echo "test_status=skipped" >> $GITHUB_OUTPUT
            echo "workflow_name=Manual Test" >> $GITHUB_OUTPUT
            echo "artifact_issue=false" >> $GITHUB_OUTPUT
          else
            # Get deployment status from deploy-reports workflow
            echo "deployment_status=${{ github.event.workflow_run.conclusion }}" >> $GITHUB_OUTPUT
            echo "trigger=auto" >> $GITHUB_OUTPUT

            # Query the GitHub API to find the triggering test workflow
            REPO="${{ github.repository }}"
            TOKEN="${{ secrets.GITHUB_TOKEN }}"
            DEPLOY_HEAD_SHA="${{ github.event.workflow_run.head_sha }}"

            # Find the most recent test workflow run for this commit
            WORKFLOWS_RESPONSE=$(curl -s -H "Authorization: token $TOKEN" \
              "https://api.github.com/repos/$REPO/actions/runs?per_page=100")

            API_STATUS=$(echo "$WORKFLOWS_RESPONSE" | jq -r '.message // "success"' 2>/dev/null || echo "parse_error")

            RECENT_RUNS=""

            # Strategy 1: Exact commit SHA match with timestamp sorting
            if [ "$WORKFLOWS_RESPONSE" != "null" ] && [ ! -z "$WORKFLOWS_RESPONSE" ] && [ "$API_STATUS" = "success" ]; then
              WORKFLOW_RUNS_CHECK=$(echo "$WORKFLOWS_RESPONSE" | jq -r '.workflow_runs // empty' 2>/dev/null)
              if [ ! -z "$WORKFLOW_RUNS_CHECK" ] && [ "$WORKFLOW_RUNS_CHECK" != "null" ]; then
                RECENT_RUNS=$(echo "$WORKFLOWS_RESPONSE" | jq -r --arg sha "$DEPLOY_HEAD_SHA" \
                  '.workflow_runs[]? | select(.head_sha == $sha and (.name == "Sanity Tests" or .name == "Regression Tests")) | "\(.created_at)|\(.name)|\(.conclusion)"' 2>/dev/null | \
                  sort -r | head -2 || echo "")
              fi
            fi

            # Strategy 2: If no exact match, find most recent test workflows within time window
            if [ -z "$RECENT_RUNS" ] && [ "$WORKFLOWS_RESPONSE" != "null" ] && [ ! -z "$WORKFLOWS_RESPONSE" ]; then
              DEPLOY_TIMESTAMP="${{ github.event.workflow_run.created_at }}"

              # Get timestamp 1 hour before deploy
              SEARCH_CUTOFF=$(date -d "$DEPLOY_TIMESTAMP - 1 hour" -Iseconds 2>/dev/null || date -u -d "$DEPLOY_TIMESTAMP - 1 hour" +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "")

              if [ ! -z "$SEARCH_CUTOFF" ]; then
                RECENT_RUNS=$(echo "$WORKFLOWS_RESPONSE" | jq -r --arg cutoff "$SEARCH_CUTOFF" \
                  '.workflow_runs[]? | select((.name == "Sanity Tests" or .name == "Regression Tests") and .created_at > $cutoff) | "\(.created_at)|\(.name)|\(.conclusion)"' 2>/dev/null | \
                  sort -r | head -2 || echo "")
              fi
            fi

            # Strategy 3: Get the most recent test workflows (fallback)
            if [ -z "$RECENT_RUNS" ] && [ "$WORKFLOWS_RESPONSE" != "null" ] && [ ! -z "$WORKFLOWS_RESPONSE" ]; then
              RECENT_RUNS=$(echo "$WORKFLOWS_RESPONSE" | jq -r \
                '.workflow_runs[]? | select(.name == "Sanity Tests" or .name == "Regression Tests") | "\(.created_at)|\(.name)|\(.conclusion)"' 2>/dev/null | \
                sort -r | head -2 || echo "")
            fi

            # Extract statuses with timestamps to determine which ran most recently
            SANITY_INFO=$(echo "$RECENT_RUNS" | grep "|Sanity Tests|" | head -1)
            REGRESSION_INFO=$(echo "$RECENT_RUNS" | grep "|Regression Tests|" | head -1)

            SANITY_STATUS=$(echo "$SANITY_INFO" | cut -d'|' -f3)
            REGRESSION_STATUS=$(echo "$REGRESSION_INFO" | cut -d'|' -f3)

            # Set defaults if not found
            SANITY_STATUS=${SANITY_STATUS:-"not_found"}
            REGRESSION_STATUS=${REGRESSION_STATUS:-"not_found"}

            # Determine the actual test status and workflow name
            if [ "$WORKFLOWS_RESPONSE" != "null" ] && [ ! -z "$WORKFLOWS_RESPONSE" ]; then
              # Get the most recent test workflow for this commit with timestamp
              MOST_RECENT_TEST=$(echo "$WORKFLOWS_RESPONSE" | jq -r --arg sha "$DEPLOY_HEAD_SHA" \
                '.workflow_runs[]? | select(.head_sha == $sha and (.name == "Sanity Tests" or .name == "Regression Tests")) | "\(.created_at)|\(.name)|\(.conclusion)"' 2>/dev/null | \
                sort -r | head -1)

              if [ ! -z "$MOST_RECENT_TEST" ] && [ "$MOST_RECENT_TEST" != "null" ]; then
                MOST_RECENT_WORKFLOW=$(echo "$MOST_RECENT_TEST" | cut -d'|' -f2)
                MOST_RECENT_STATUS=$(echo "$MOST_RECENT_TEST" | cut -d'|' -f3)

                TEST_STATUS="$MOST_RECENT_STATUS"
                WORKFLOW_NAME="$MOST_RECENT_WORKFLOW"
              elif [ "$SANITY_STATUS" != "not_found" ] && [ "$SANITY_STATUS" != "null" ]; then
                TEST_STATUS="$SANITY_STATUS"
                WORKFLOW_NAME="Sanity Tests"
              elif [ "$REGRESSION_STATUS" != "not_found" ] && [ "$REGRESSION_STATUS" != "null" ]; then
                TEST_STATUS="$REGRESSION_STATUS"
                WORKFLOW_NAME="Regression Tests"
              else
                TEST_STATUS="unknown"
                WORKFLOW_NAME="Unknown Test"
              fi
            else
              # Fallback logic
              if [ "$SANITY_STATUS" != "not_found" ]; then
                TEST_STATUS="$SANITY_STATUS"
                WORKFLOW_NAME="Sanity Tests"
              elif [ "$REGRESSION_STATUS" != "not_found" ]; then
                TEST_STATUS="$REGRESSION_STATUS"
                WORKFLOW_NAME="Regression Tests"
              else
                TEST_STATUS="unknown"
                WORKFLOW_NAME="Unknown Test"
              fi
            fi

            # Check if this is an artifact/deployment issue
            ARTIFACT_ISSUE="false"
            if [ "$TEST_STATUS" == "success" ] && [ "${{ github.event.workflow_run.conclusion }}" == "failure" ]; then
              ARTIFACT_ISSUE="true"
            fi

            echo "test_status=${TEST_STATUS}" >> $GITHUB_OUTPUT
            echo "workflow_name=${WORKFLOW_NAME}" >> $GITHUB_OUTPUT
            echo "artifact_issue=${ARTIFACT_ISSUE}" >> $GITHUB_OUTPUT
          fi

          # Get current date/time in UTC
          CURRENT_TIME=$(date '+%d-%m-%Y %H:%M:%S UTC')
          echo "current_time=$CURRENT_TIME" >> $GITHUB_OUTPUT

      - name: Notify Slack on Test Success
        if: steps.status.outputs.test_status == 'success'
        uses: slackapi/slack-github-action@v2.1.1
        with:
          webhook-type: incoming-webhook
          payload: |
            {
              "channel": "#testing-updates",
              "text": "âœ… Test Workflow Completed Successfully!",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "âœ… Test Workflow Completed Successfully!"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ðŸ§ª Test Workflow Status\n\n*Workflow:* ${{ steps.status.outputs.workflow_name }}\n*Status:* âœ… PASSED\n*Repository:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}"
                  }
                },
                {
                  "type": "divider"
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ðŸ“Š Report Deployment Status\n\n*Status:* ${{ steps.status.outputs.deployment_status == 'success' && 'âœ… DEPLOYED SUCCESSFULLY' || 'âš ï¸ DEPLOYMENT HAD ISSUES' }}\n*Deployed at:* ${{ steps.status.outputs.current_time }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{ steps.status.outputs.deployment_status == 'success' && 'ðŸŽ‰ Great work! All tests passed and reports are now live!' || 'âœ… Tests passed but there were deployment issues. Reports may be delayed.' }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on Test Failure
        if: steps.status.outputs.test_status == 'failure'
        uses: slackapi/slack-github-action@v2.1.1
        with:
          webhook-type: incoming-webhook
          payload: |
            {
              "channel": "#testing-updates",
              "text": "âŒ Tests Failed!",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "âŒ Tests Failed!"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ðŸ§ª Test Workflow Status\n\n*Workflow:* ${{ steps.status.outputs.workflow_name }}\n*Status:* âŒ FAILED\n*Repository:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}"
                  }
                },
                {
                  "type": "divider"
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ðŸ“Š Report Deployment Status\n\n*Status:* ${{ steps.status.outputs.deployment_status == 'success' && 'âœ… REPORTS DEPLOYED (Failed Test Results)' || 'âŒ DEPLOYMENT ALSO FAILED' }}\n*Deployed at:* ${{ steps.status.outputs.current_time }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "âš ï¸ **Action Required:** Some tests failed. Check the detailed test report to see which tests need attention."
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "ðŸ“‹ Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on Unknown Test Status
        if: steps.status.outputs.test_status == 'unknown'
        uses: slackapi/slack-github-action@v2.1.1
        with:
          webhook-type: incoming-webhook
          payload: |
            {
              "channel": "#testing-updates",
              "text": "ðŸ¤· Test Status Unknown - Deployment Completed",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "ðŸ¤· Test Status Unknown - Deployment Completed"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ðŸ§ª Test Workflow Status\n\n*Workflow:* ${{ steps.status.outputs.workflow_name }}\n*Status:* ðŸ¤· UNKNOWN\n*Repository:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}"
                  }
                },
                {
                  "type": "divider"
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ðŸ“Š Deployment Status\n\n*Status:* ${{ steps.status.outputs.deployment_status == 'success' && 'âœ… DEPLOYED' || 'âŒ FAILED' }}\n*Deployed at:* ${{ steps.status.outputs.current_time }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "âš ï¸ Could not determine test status. Please check the workflow runs manually."
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "ðŸ“‹ Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Add notification status to summary
        run: |
          echo "ðŸ“± Slack Notification Sent!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“Š Deployment Status: ${{ steps.status.outputs.deployment_status }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ§ª Test Status: ${{ steps.status.outputs.test_status }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”„ Workflow: ${{ steps.status.outputs.workflow_name }}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”” Trigger: ${{ steps.status.outputs.trigger }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.status.outputs.artifact_issue }}" == "true" ]; then
            echo "ðŸ“¦ Artifact Issue: GitHub storage quota exceeded" >> $GITHUB_STEP_SUMMARY
            echo "â³ Note: Storage quota typically refreshes within 6-12 hours" >> $GITHUB_STEP_SUMMARY
          fi
          echo "â° Sent at: ${{ steps.status.outputs.current_time }}" >> $GITHUB_STEP_SUMMARY
